# 08 — Deployment: Ship It

> **What you'll learn:** How to get your oracle running in production — pre-flight checks, Docker deployment, network selection, and keeping things healthy after launch.

---

## 08.1 — Pre-deployment Checklist

Before deploying, make sure you have:

- **Oracle entity registered on-chain** — created during [Quickstart Step 3](./01-quickstart.md#step-3-scaffold-your-project)
- **All Matrix credentials** — `MATRIX_BASE_URL`, `MATRIX_RECOVERY_PHRASE`, `MATRIX_ORACLE_ADMIN_ACCESS_TOKEN`, `MATRIX_ORACLE_ADMIN_USER_ID`, `MATRIX_ORACLE_ADMIN_PASSWORD`, `MATRIX_ACCOUNT_ROOM_ID`, `MATRIX_VALUE_PIN`
- **OpenRouter API key** — `OPEN_ROUTER_API_KEY` (starts with `sk-or-v1-`)
- **Wallet mnemonic** — `SECP_MNEMONIC` (generated by the CLI)
- **Oracle entity DID** — `ORACLE_ENTITY_DID`
- **Network decided** — `NETWORK` set to `devnet`, `testnet`, or `mainnet`
- **Database credentials** — `REDIS_URL`, `SQLITE_DATABASE_PATH`
- **Docker installed** — check with `docker --version` (for self-hosted) or a **Railway account** (for cloud deployment)
- **Skills configured** — any skills your oracle uses should be tested locally first

> See [Environment Variables Reference](./reference/environment-variables.md) for the complete list of all configuration options.

---

## 08.2 — Deploy with Docker (Self-hosted)

The project includes everything you need to run your oracle and its services with Docker Compose.

### Build the oracle image

There are two Dockerfiles to choose from:

| File         | Base   | Best for               |
| ------------ | ------ | ---------------------- |
| `Dockerfile` | Debian | The default Dockerfile |

Build with:

```bash
docker build -t my-oracle:latest --build-arg PROJECT=app -f Dockerfile .
```

### What runs in Docker Compose

The `docker-compose.yml` starts everything your oracle needs:

| Service           | Port | What it does                                  |
| ----------------- | ---- | --------------------------------------------- |
| **app**           | 3000 | Your oracle application                       |
| **redis**         | 6379 | Session storage and caching                   |
| **redis-insight** | 8001 | Redis management UI (optional, for debugging) |

### Set up your environment

Make sure your `apps/app/.env` file has all the production values from the [pre-deployment checklist](#081--pre-deployment-checklist). The `docker-compose.yml` reads this file automatically.

### Start everything

```bash
docker compose up -d
```

Check that all services are running:

```bash
docker compose ps
```

You should see all services in a "running" or "healthy" state.

### View logs

```bash
docker compose logs -f app
```

### Stop everything

```bash
docker compose down
```

> Data is preserved in Docker volumes (`redis-data`). To wipe everything and start fresh: `docker compose down -v`

---

## 08.3 — Deploy to Railway

[Railway](https://railway.com) lets you deploy your oracle from a Docker Compose file — no server management, no Kubernetes. You get a URL, your services run, and Railway handles the rest.

### Step 1 — Install the Railway CLI and log in

```bash
# Install (pick one)
brew install railway            # macOS
npm i -g @railway/cli           # any platform with Node.js 16+
bash <(curl -fsSL cli.new)      # Linux / macOS shell script
```

Then log in:

```bash
railway login
```

### Step 2 — Create a project and link it

```bash
railway init
```

This creates a new project on Railway and links your local directory to it. You'll choose a project name when prompted.

### Step 2.5 — Configure Docker build cache

Railway supports Docker cache mounts to speed up builds. The `Dockerfile` uses cache mounts for the pnpm store, but they need your Railway **service ID** to work.

After linking your project, get your service ID and update the Dockerfile:

```bash
# Get your service ID
railway status --json | jq -r '.services.edges[0].node.id'
```

Then replace the existing service ID in the `Dockerfile` cache mount lines with yours:

```bash
SERVICE_ID=$(railway status --json | jq -r '.services.edges[0].node.id')
sed -i'' -e "s|id=s/[a-f0-9-]*-/root/.pnpm-store|id=s/${SERVICE_ID}-/root/.pnpm-store|g" Dockerfile
echo "Updated Dockerfile with service ID: $SERVICE_ID"
```

This patches the cache mount lines so Railway persists your pnpm store between builds — cutting install times significantly after the first deploy.

### Step 3 — Import your Docker Compose file

1. Open your project dashboard — run `railway open` or go to [railway.com/dashboard](https://railway.com/dashboard)
2. Drag and drop your `docker-compose.yml` onto the project canvas
3. Railway auto-creates each service (app, Redis, redis-insight) as separate items on the canvas
4. Review the staged changes and click **Deploy**

> Railway supports most Compose configs, but not every option. If something doesn't import cleanly, you can create services manually on the canvas instead.

### Step 4 — Set environment variables

Click on the **app** service → **Variables** tab. Add all the variables from the [pre-deployment checklist](#081--pre-deployment-checklist).

**Quickest way:** Open the **Raw Editor** and paste your entire `.env` file — Railway parses it automatically.

For `REDIS_URL`, use a **reference variable** to point to Railway's internal Redis service:

```
REDIS_URL=redis://${{Redis.RAILWAY_PRIVATE_DOMAIN}}:6379
```

Railway's autocomplete dropdown helps you wire up references. This uses private networking — services talk to each other over encrypted internal connections, never touching the public internet.

**Tip:** For variables shared across multiple services, use **Project Settings → Shared Variables** and reference them with `${{shared.VARIABLE_KEY}}`.

> See [Environment Variables Reference](./reference/environment-variables.md) for the full list.

### Step 5 — Add persistent storage

Your oracle stores Matrix encryption keys and SQLite data on disk. Without a volume, this data is lost on every redeploy.

1. Right-click on the canvas (or press `⌘K`) → **Add Volume**
2. Attach it to the **app** service
3. Set the mount path to `/app/apps/app/matrix-storage`

For SQLite, make sure `SQLITE_DATABASE_PATH` points to a path inside the same volume mount:

```
SQLITE_DATABASE_PATH=/app/apps/app/matrix-storage/sqlite.db
```

### Step 6 — Deploy your code

From your project directory, deploy the app service:

```bash
railway up
```

This uploads your local code to Railway, builds it using the `Dockerfile`, and deploys it. Use `railway up --detach` to deploy without streaming the build logs.

**Auto-deploy from GitHub (optional):** Instead of `railway up`, you can connect a GitHub repo for automatic deploys on every push:

1. Click on the **app** service → **Settings → Source**
2. Connect your GitHub repo and select the branch
3. Set the **Dockerfile path** to `Dockerfile`
4. Under **Build Configuration**, add the build argument: `PROJECT` = `app`

### Step 7 — Generate a public domain

1. Click on the **app** service → **Settings → Networking**
2. Under **Public Networking**, click **Generate Domain**
3. You'll get a URL like `your-oracle-abc123.up.railway.app`

To use your own domain, add a CNAME record pointing to the Railway domain. Railway handles SSL automatically.

### Step 8 — Verify

Hit your domain to confirm the oracle is alive:

```bash
curl https://your-oracle-abc123.up.railway.app/
```

Check the service logs with `railway logs` or in the dashboard if anything looks off.

---

## 08.4 — After Deployment

### Health check

Hit the root endpoint to verify your oracle is alive:

```bash
curl https://your-oracle-domain.com/
```

`GET /` returns the application status. Use this URL for load balancer health probes or uptime monitors.

### Network selection

Your oracle connects to a specific IXO network. Choose based on where you are in the development cycle:

| Network | Purpose                 | When to use                  |
| ------- | ----------------------- | ---------------------------- |
| devnet  | Development and testing | Building and iterating       |
| testnet | Staging and QA          | Pre-production validation    |
| mainnet | Production              | Live users and real payments |

To switch networks, update the `NETWORK` variable in your environment, then update your on-chain entity:

```bash
oracles-cli update-entity
```

> See [Network URLs Reference](./01-quickstart.md#network-urls-reference) for the full list of Matrix, RPC, and Portal URLs per network.

### Graceful shutdown

On SIGTERM/SIGINT, the oracle saves its conversation state before shutting down — no data is lost during redeployments.

### Updating and redeploying

When you push changes (new skills, updated prompts, configuration tweaks):

**Docker (self-hosted):**

```bash
docker build -t my-oracle:latest --build-arg PROJECT=app -f Dockerfile .
docker compose up -d
```

Docker Compose will replace the `app` container with the new image. The infrastructure services (Redis) keep running and retain their data.

**Railway:**

If you connected a GitHub repo (Step 6 above), Railway redeploys automatically on every push. No manual steps needed.

To deploy manually from your local directory:

```bash
railway up
```

Or to redeploy the latest version without uploading new code:

```bash
railway redeploy
```

### Monitoring with Langfuse

Langfuse gives you visibility into your oracle's LLM calls — what was sent, what came back, how long it took, and how much it cost. Add these to your environment:

```env
LANGFUSE_PUBLIC_KEY=pk-lf-...
LANGFUSE_SECRET_KEY=sk-lf-...
LANGFUSE_HOST=https://cloud.langfuse.com
```

Sign up at [langfuse.com](https://langfuse.com) to get your keys.

---

## Next Steps

- **[01 — Quickstart](./01-quickstart.md)** — if you haven't set up your oracle yet
- **[04 — Working with Skills](./04-working-with-skills.md)** — add new capabilities before deploying
- **[Environment Variables Reference](./reference/environment-variables.md)** — full list of all config options
