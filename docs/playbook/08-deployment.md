# 08 — Deployment: Ship It

> **What you'll learn:** How to get your oracle running in production — pre-flight checks, Docker deployment, network selection, and keeping things healthy after launch.

---

## 08.1 — Pre-deployment Checklist

Before deploying, make sure you have:

- **Oracle entity registered on-chain** — created during [Quickstart Step 3](./01-quickstart.md#step-3-scaffold-your-project)
- **All Matrix credentials** — `MATRIX_BASE_URL`, `MATRIX_RECOVERY_PHRASE`, `MATRIX_ORACLE_ADMIN_ACCESS_TOKEN`, `MATRIX_ORACLE_ADMIN_USER_ID`, `MATRIX_ORACLE_ADMIN_PASSWORD`, `MATRIX_ACCOUNT_ROOM_ID`, `MATRIX_VALUE_PIN`
- **OpenRouter API key** — `OPEN_ROUTER_API_KEY` (starts with `sk-or-v1-`)
- **Wallet mnemonic** — `SECP_MNEMONIC` (generated by the CLI)
- **Oracle entity DID** — `ORACLE_ENTITY_DID`
- **Network decided** — `NETWORK` set to `devnet`, `testnet`, or `mainnet`
- **Database credentials** — `REDIS_URL`, `SQLITE_DATABASE_PATH`
- **Docker installed** — check with `docker --version` (for self-hosted) or a **[Fly.io](https://fly.io) account** (for cloud deployment)
- **Skills configured** — any skills your oracle uses should be tested locally first

> See [Environment Variables Reference](./reference/environment-variables.md) for the complete list of all configuration options.

---

## 08.2 — Deploy with Docker (Self-hosted)

The project includes everything you need to run your oracle and its services with Docker Compose.

### Build the oracle image

There are two Dockerfiles to choose from:

| File         | Base   | Best for               |
| ------------ | ------ | ---------------------- |
| `Dockerfile` | Debian | The default Dockerfile |

Build with:

```bash
docker build -t my-oracle:latest --build-arg PROJECT=app -f Dockerfile .
```

### What runs in Docker Compose

The `docker-compose.yml` starts everything your oracle needs:

| Service           | Port | What it does                                  |
| ----------------- | ---- | --------------------------------------------- |
| **app**           | 3000 | Your oracle application                       |
| **redis**         | 6379 | Session storage and caching                   |
| **redis-insight** | 8001 | Redis management UI (optional, for debugging) |

### Set up your environment

Make sure your `apps/app/.env` file has all the production values from the [pre-deployment checklist](#081--pre-deployment-checklist). The `docker-compose.yml` reads this file automatically.

### Start everything

```bash
docker compose up -d
```

Check that all services are running:

```bash
docker compose ps
```

You should see all services in a "running" or "healthy" state.

### View logs

```bash
docker compose logs -f app
```

### Stop everything

```bash
docker compose down
```

> Data is preserved in Docker volumes (`redis-data`). To wipe everything and start fresh: `docker compose down -v`

---

## 08.3 — Deploy to Fly.io

[Fly.io](https://fly.io) runs your oracle in lightweight VMs close to your users — no server management. You get a URL, persistent storage, and auto-deploys from GitHub.

### Step 1 — Set up Fly.io

Install flyctl, log in, and create your app:

```bash
# Install (pick one)
brew install flyctl            # macOS
curl -L https://fly.io/install.sh | sh  # Linux

# Log in
fly auth login

# Create your app — uses the fly.toml already in the repo
fly launch
```

When `fly launch` detects the existing `fly.toml`, it will ask if you want to use it — say **yes**. This creates your app on Fly.io with the correct configuration already set up.

### Step 2 — Set up Redis

```bash
fly redis create
```

Choose the same region as your app and pick a plan. After creation, copy the **Private URL** from `fly redis status <database-name>` and add it as `REDIS_URL` in your `apps/app/.env` file.

> **Alternative:** Use any external Redis provider — you just need the connection URL.

### Step 3 — Fill in your `.env`

Make sure your `apps/app/.env` has all the production values from the [pre-deployment checklist](#081--pre-deployment-checklist).

### Step 4 — Deploy

Once the setup is done, deploy with a single command:

```bash
pnpm run deploy
```

This script handles everything for you:
- Creates the persistent storage volume (if it doesn't exist)
- Loads all secrets from your `.env` file
- Sets the correct storage paths for the Fly.io volume
- Builds and deploys the Docker image

First deploy takes a few minutes; subsequent deploys are faster.

### Step 5 — Verify

```bash
fly status                                        # machine is running?
curl https://your-app-name.fly.dev/                # oracle is alive?
fly logs                                          # check logs if needed
```

### Auto-deploy from GitHub (optional)

The repo includes `.github/workflows/fly-deploy.yml` which auto-deploys on every push to `main`. To enable it:

1. Generate a deploy token:
   ```bash
   fly tokens create deploy -x 999999h
   ```
2. Add it as `FLY_API_TOKEN` in your GitHub repo → **Settings → Secrets and variables → Actions**
3. Every push to `main` now auto-deploys to Fly.io

---

## 08.4 — After Deployment

### Health check

Hit the root endpoint to verify your oracle is alive:

```bash
curl https://your-oracle-domain.fly.dev/
```

`GET /` returns the application status. The `fly.toml` already configures automatic health checks — Fly.io will restart the machine if it stops responding.

### Network selection

Your oracle connects to a specific IXO network. Choose based on where you are in the development cycle:

| Network | Purpose                 | When to use                  |
| ------- | ----------------------- | ---------------------------- |
| devnet  | Development and testing | Building and iterating       |
| testnet | Staging and QA          | Pre-production validation    |
| mainnet | Production              | Live users and real payments |

To switch networks, update the `NETWORK` variable in your environment, then update your on-chain entity:

```bash
qiforge update-entity
```

> See [Network URLs Reference](./01-quickstart.md#network-urls-reference) for the full list of Matrix, RPC, and Portal URLs per network.

### Graceful shutdown

On SIGTERM, the oracle saves its conversation state before shutting down — no data is lost during redeployments. The `fly.toml` gives the app 30 seconds to finish cleanup before forcing a stop.

### Updating and redeploying

When you push changes (new skills, updated prompts, configuration tweaks):

**Docker (self-hosted):**

```bash
docker build -t my-oracle:latest --build-arg PROJECT=app -f Dockerfile .
docker compose up -d
```

Docker Compose will replace the `app` container with the new image. The infrastructure services (Redis) keep running and retain their data.

**Fly.io:**

If you set up GitHub Actions (Step 8 above), Fly.io redeploys automatically on every push to `main`. No manual steps needed.

To deploy manually:

```bash
fly deploy
```

### Resetting a stale Matrix token

If your oracle fails on startup with Matrix authentication or crypto errors, the access token has likely gone stale. When this happens, the on-disk crypto store is tied to the old token/device — simply updating the token won't fix it. You need to wipe the storage and get a fresh token together.

The included script handles the full recovery:

```bash
./scripts/reset-matrix.sh
```

**What it does:**

1. Destroys the Fly machine (unbinds the volume)
2. Deletes the volume (wipes the crypto store and all `/data`)
3. Logs into Matrix with your password to get a fresh access token
4. Sets the new token as a Fly secret
5. Creates a fresh volume
6. Deploys with clean storage and the new token

The script reads `MATRIX_BASE_URL`, `MATRIX_ORACLE_ADMIN_USER_ID`, and `MATRIX_ORACLE_ADMIN_PASSWORD` from your `.env` file. To use a different env file:

```bash
./scripts/reset-matrix.sh path/to/your/.env
```

After it finishes, verify with `fly logs` — you should see the oracle log in to Matrix successfully and bootstrap fresh cross-signing.

> **Note:** This wipes all persistent data (checkpoints, crypto store). The oracle will start fresh — conversation history stored in Matrix rooms is unaffected.

### Monitoring with Langfuse

Langfuse gives you visibility into your oracle's LLM calls — what was sent, what came back, how long it took, and how much it cost. Add these to your environment:

```env
LANGFUSE_PUBLIC_KEY=pk-lf-...
LANGFUSE_SECRET_KEY=sk-lf-...
LANGFUSE_HOST=https://cloud.langfuse.com
```

Sign up at [langfuse.com](https://langfuse.com) to get your keys.

---

## Next Steps

- **[01 — Quickstart](./01-quickstart.md)** — if you haven't set up your oracle yet
- **[04 — Working with Skills](./04-working-with-skills.md)** — add new capabilities before deploying
- **[Environment Variables Reference](./reference/environment-variables.md)** — full list of all config options
